// Generated by CoffeeScript 1.3.3
/*

Android Pattern Lock Screen 
http://cheghamwassim.com/apps/js/android-lock-screen/

Copyright 2012, Wassim Chegham
Licensed under the MIT or GPL Version 2 licenses.

The Pattern class.
@constructor
@private
*/

var Pattern;

Pattern = (function() {

  function Pattern(o) {
    var mousePos, stage;
    this._userDots = [];
    this._savedPattern = [];
    stage = o.patternLayer.getStage();
    mousePos = stage.getMousePosition() || {
      x: stage.getWidth() / 2,
      y: stage.getHeight() / 2
    };
    this._x0 = mousePos.x;
    this._y0 = mousePos.y;
    this._x = this._x0;
    this._y = this._y0;
    this._patternLayer = o.patternLayer;
    this._lineLayer = o.lineLayer;
    this._hintLayer = o.hintLayer;
    this._isRecording = false;
    this._toBeClearedOnNextUse = false;
  }

  Pattern.prototype.setRecording = function(state) {
    this._isRecording = state;
    return true;
  };

  Pattern.prototype.setToBeClearedOnNextUse = function(state) {
    this._toBeClearedOnNextUse = state;
    return true;
  };

  Pattern.prototype.buildHint = function() {
    var line;
    this._hintLayer.removeChildren();
    line = this._newLine(this._savedPattern);
    this._hintLayer.add(line);
    return true;
  };

  Pattern.prototype.showHint = function() {
    this._hintLayer.show();
    this._hintLayer.draw();
    return true;
  };

  Pattern.prototype.hideHint = function() {
    this._hintLayer.hide();
    this._hintLayer.draw();
    return true;
  };

  Pattern.prototype.addDot = function(dot, config) {
    var shouldDrawDot;
    if (this._toBeClearedOnNextUse) {
      this.clear();
      this._toBeClearedOnNextUse = false;
    }
    shouldDrawDot = this.shouldDrawDot(dot);
    if (shouldDrawDot) {
      if (this._isRecording) {
        this.savePatternDot(dot);
      } else if (shouldDrawDot) {
        this.addUserDot(dot);
      }
      this._patternLayer.add(dot);
      this.setTransition(dot, config);
      this._patternLayer.draw();
    }
    return true;
  };

  Pattern.prototype.shouldDrawDot = function(dot) {
    var d, dots, _i, _len;
    dots = this._isRecording ? this._savedPattern : this._userDots;
    for (_i = 0, _len = dots.length; _i < _len; _i++) {
      d = dots[_i];
      if (dot.getX() === d.getX() && dot.getY() === d.getY()) {
        return false;
      }
    }
    return true;
  };

  Pattern.prototype.setTransition = function(dot, config) {
    var _this = this;
    (function() {
      return dot.transitionTo({
        radius: config.radius,
        duration: 0.1,
        callback: _this.drawLine.bind(_this)
      });
    })();
    return true;
  };

  Pattern.prototype.addUserDot = function(dot) {
    this._userDots.push(dot);
    return true;
  };

  Pattern.prototype.drawLine = function() {
    var dots, line;
    dots = this._isRecording ? this._savedPattern : this._userDots;
    if (dots.length >= 2) {
      line = this._newLine(dots);
      this._lineLayer.removeChildren();
      this._lineLayer.add(line);
      this._lineLayer.draw();
    }
    return true;
  };

  Pattern.prototype._newLine = function(dots) {
    return new Kinetic.Shape({
      drawFunc: function() {
        var ctx, dot, dot1, i, _i, _ref;
        dot1 = dots[0];
        ctx = this.getContext();
        ctx.beginPath();
        ctx.moveTo(dot1.getX(), dot1.getY());
        for (i = _i = 1, _ref = dots.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          dot = dots[i];
          ctx.lineTo(dot.getX(), dot.getY());
        }
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.closePath();
        return true;
      },
      stroke: "rgba(255,255,255,0.5)",
      strokeWidth: 5
    });
  };

  Pattern.prototype.isValid = function() {
    var i, savedPattern, _i, _len, _ref;
    if (this._savedPattern.length !== this._userDots.length) {
      return false;
    }
    _ref = this._savedPattern;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      savedPattern = _ref[i];
      if (savedPattern.getX() !== this._userDots[i].getX() || savedPattern.getY() !== this._userDots[i].getY()) {
        return false;
      }
    }
    return true;
  };

  Pattern.prototype.clear = function() {
    this._clearUserDots();
    this._clearLayers();
    return this;
  };

  Pattern.prototype._clearUserDots = function() {
    return this._userDots = [];
  };

  Pattern.prototype._clearLayers = function() {
    var dot, dots, i, l, _fn, _i, _len,
      _this = this;
    dots = this._patternLayer.getChildren();
    l = dots.length;
    _fn = function() {
      return dot.transitionTo({
        radius: 0,
        duration: 0.1,
        callback: function() {
          if (l - 1 === i) {
            _this._patternLayer.clear();
            _this._patternLayer.removeChildren();
            _this._patternLayer.draw();
            return true;
          }
          return false;
        }
      });
    };
    for (i = _i = 0, _len = dots.length; _i < _len; i = ++_i) {
      dot = dots[i];
      _fn();
    }
    this._lineLayer.clear();
    this._lineLayer.removeChildren();
    this._lineLayer.draw();
    return true;
  };

  Pattern.prototype.savePatternDot = function(dot) {
    this._savedPattern.push({
      x: dot.getX(),
      y: dot.getY(),
      getX: function() {
        return this.x;
      },
      getY: function() {
        return this.y;
      }
    });
    return true;
  };

  Pattern.prototype.clearSavedPattern = function() {
    this._savedPattern = [];
    this._hintLayer.removeChildren();
    this._hintLayer.clear();
    this._hintLayer.draw();
    return true;
  };

  return Pattern;

})();
