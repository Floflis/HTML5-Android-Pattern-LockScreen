// Generated by CoffeeScript 1.3.3
(function() {
  var Dot, LockScreen, Pattern;

  window.addEventListener("load", function() {
    var app, resetButton, savePatternButton, toggleShowHint, unlockButton;
    app = new LockScreen({
      container: "lock-screen",
      width: 400,
      height: 400,
      onSuccess: function() {
        return console.log("Pattern successed");
      },
      onFailure: function() {
        return console.log("Pattern unmatched");
      },
      pattern: "1-2-3-4-5-6-7-8-9"
    });
    unlockButton = document.getElementById("unlock-button");
    savePatternButton = document.getElementById("save-pattern-button");
    resetButton = document.getElementById("reset-button");
    toggleShowHint = true;
    savePatternButton.addEventListener("click", (function() {
      var span;
      span = this.getElementsByClassName("gray");
      if (span.className === "red") {
        this.innerHTML = "<span class='gray'></span>Record Pattern";
        span.className = "gray";
        app.stopRecordPattern();
        unlockButton.style.display = "inline";
        resetButton.style.display = "inline";
      } else {
        this.innerHTML = "<span class='red'></span>Recording...";
        span.className = "red";
        app.startRecordPattern();
        unlockButton.style.display = "none";
        resetButton.style.display = "none";
      }
      return true;
    }), false);
    unlockButton.addEventListener("click", (function() {
      var _this = this;
      if (app.unlock() !== false) {
        this.className = "button green";
        alert("Access Granted!");
      } else {
        this.className = "button red";
        setTimeout((function() {
          _this.className = "button blue";
          app.clear();
          return true;
        }), 1000);
      }
      return true;
    }), false);
    resetButton.addEventListener("click", (function() {
      app.reset();
      unlockButton.className = "button blue";
      return true;
    }), false);
    document.addEventListener("keyup", (function(e) {
      if ((e.keyCode || e.which) === 72) {
        app.showHint(toggleShowHint);
        toggleShowHint = !toggleShowHint;
      }
      return true;
    }));
    return true;
  });

  Dot = (function() {

    function Dot(id, o) {
      var minDotRadius, stage,
        _this = this;
      this._id = id;
      this._x = o.x;
      this._y = o.y;
      this._dotInnerLayer = o.innerLayer;
      this._listenerLayer = o.listenerLayer;
      this._pattern = o.pattern;
      this._innerCircleRadius = 5;
      this._innerCircleFill = "rgba(255,255,255,0)";
      this._innerCircleStroke = "#aaa";
      this._strokeWidth = 4;
      stage = this._dotInnerLayer.getStage();
      minDotRadius = Math.min(stage.getWidth(), stage.getHeight());
      this._outerCircleConfig = {
        radius: minDotRadius / 10,
        fill: "rgba(255,255,255,0)",
        stroke: "lime",
        strokeWidth: this._strokeWidth
      };
      this._innerCircle = (function() {
        return new Kinetic.Circle({
          x: _this._x,
          y: _this._y,
          radius: _this._innerCircleRadius,
          fill: _this._innerCircleFill,
          stroke: _this._innerCircleStroke,
          strokeWidth: _this._strokeWidth
        });
      })();
      this._listenerCircle = (function() {
        return new Kinetic.Circle({
          x: _this._x,
          y: _this._y,
          radius: _this._outerCircleConfig.radius,
          fill: 'transparent'
        });
      })();
      this._listenerCircle.on("mousedown mousemove touchmove", this._showUserDot.bind(this));
      this._listenerCircle.on("mouseout", this._mouseout.bind(this));
      this._listenerCircle.on("mouseup touchend", this._isValid.bind(this));
      this._listenerLayer.add(this._listenerCircle);
      this._dotInnerLayer.add(this._innerCircle);
      this._dotInnerLayer.draw();
    }

    Dot.prototype.getX = function() {
      return this._x;
    };

    Dot.prototype.getY = function() {
      return this._y;
    };

    Dot.prototype._isValid = function() {
      var btn, event;
      if (this._pattern.isRecording) {
        return false;
      }
      event = (function() {
        if (document.createEvent) {
          event = document.createEvent("HTMLEvents");
          event.initEvent("click", true, true);
          return event;
        } else {
          event = document.createEventObject();
          event.eventType = "click";
          return event;
        }
      })();
      btn = document.getElementById("unlock-button");
      if (btn.dispatchEvent) {
        btn.dispatchEvent(event);
      } else if (btn.fireEvent) {
        btn.fireEvent("on" + event.eventType, event);
      }
      return true;
    };

    Dot.prototype._showUserDot = function() {
      var outerCircle,
        _this = this;
      document.body.style.cursor = "pointer";
      this._innerCircle.setStrokeWidth(2);
      this._dotInnerLayer.draw();
      outerCircle = (function() {
        return new Kinetic.Circle({
          x: _this._innerCircle.getX(),
          y: _this._innerCircle.getY(),
          radius: 0,
          fill: _this._outerCircleConfig.fill,
          stroke: _this._outerCircleConfig.stroke,
          strokeWidth: _this._outerCircleConfig.strokeWidth
        });
      })();
      return this._pattern.addDot(outerCircle, this._outerCircleConfig);
    };

    Dot.prototype._mouseover = function() {
      document.body.style.cursor = "pointer";
      return true;
    };

    Dot.prototype._mouseout = function() {
      document.body.style.cursor = "default";
      return true;
    };

    Dot.prototype.clear = function() {
      this._innerCircle.setFill(this._innerCircleFill);
      this._innerCircle.setRadius(this._innerCircleRadius);
      this._innerCircle.setStrokeWidth(this._innerCircleRadius);
      this._dotInnerLayer.draw();
      return true;
    };

    return Dot;

  })();

  LockScreen = (function() {

    function LockScreen(options) {
      var _this = this;
      this._name = "LockScreen";
      try {
        window.Kinetic;
      } catch (error) {
        throw "[" + this._name + "] Kinetic.js was not detected!";
      }
      try {
        options.container;
      } catch (error) {
        throw "[" + this._name + "] A container must be specified!";
      }
      this._config = {};
      this._config.width = options.width || 400;
      this._config.height = options.height || 400;
      this._config.container = options.container || null;
      this._config.onSuccess = options.onSuccess || null;
      this._config.onFailure = options.onFailure || null;
      this._config.pattern = options.pattern || null;
      this._stage = (function() {
        return new Kinetic.Stage({
          container: _this._config.container,
          width: _this._config.width,
          height: _this._config.height
        });
      })();
      this._dotsInnerLayer = new Kinetic.Layer();
      this._dotsOuterLayer = new Kinetic.Layer();
      this._lineLayer = new Kinetic.Layer();
      this._listenerLayer = new Kinetic.Layer();
      this._hintLayer = new Kinetic.Layer();
      this._hintLayer.setAlpha(0.1);
      this._stage.add(this._dotsInnerLayer);
      this._stage.add(this._dotsOuterLayer);
      this._stage.add(this._lineLayer);
      this._stage.add(this._hintLayer);
      this._stage.add(this._listenerLayer);
      this._pattern = (function() {
        return new Pattern({
          patternLayer: _this._dotsOuterLayer,
          lineLayer: _this._lineLayer,
          hintLayer: _this._hintLayer
        });
      })();
      this._dots = [];
      this._draw();
      if (this._config.pattern != null) {
        this._parseAndSaveUserPattern(this._config.pattern);
      }
      return this;
    }

    LockScreen.prototype._parseAndSaveUserPattern = function(pattern) {
      var dot, dotPosition, patternArray, patternNumber, _i, _len;
      patternArray = pattern.split(/[#\|_,; -]+/);
      for (_i = 0, _len = patternArray.length; _i < _len; _i++) {
        patternNumber = patternArray[_i];
        dotPosition = +patternNumber - 1;
        dot = this._dots[dotPosition];
        if (this._pattern.shouldDrawDot(dot)) {
          this._pattern.savePatternDot(dot);
        }
      }
      this._pattern.buildHint();
      return true;
    };

    LockScreen.prototype._draw = function() {
      var h, i, mH, mW, offsetH, offsetW, options, point, points, w, _i, _len;
      w = this._stage.getWidth();
      h = this._stage.getHeight();
      mW = Math.floor(w / 2);
      mH = Math.floor(h / 2);
      offsetW = Math.floor(w / 3);
      offsetH = Math.floor(h / 3);
      points = [
        {
          x: mW - offsetW,
          y: mH - offsetH
        }, {
          x: mW,
          y: mH - offsetH
        }, {
          x: mW + offsetW,
          y: mH - offsetH
        }, {
          x: mW - offsetW,
          y: mH
        }, {
          x: mW,
          y: mH
        }, {
          x: mW + offsetW,
          y: mH
        }, {
          x: mW - offsetW,
          y: mH + offsetH
        }, {
          x: mW,
          y: mH + offsetH
        }, {
          x: mW + offsetW,
          y: mH + offsetH
        }
      ];
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        point = points[i];
        options = {
          pattern: this._pattern,
          innerLayer: this._dotsInnerLayer,
          listenerLayer: this._listenerLayer,
          x: point.x,
          y: point.y
        };
        this._dots.push(new Dot(i, options));
      }
      return this;
    };

    LockScreen.prototype.clear = function() {
      var dot, _i, _len, _ref;
      this._pattern.clear();
      _ref = this._dots;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dot = _ref[_i];
        dot.clear();
      }
      return this;
    };

    LockScreen.prototype.reset = function() {
      this.clear();
      this._pattern.clearSavedPattern();
      return this;
    };

    LockScreen.prototype.unlock = function() {
      var _ref, _ref1;
      if (this._pattern.isValid()) {
        this.validatePattern();
        if ((_ref = this._config.onSuccess) != null) {
          _ref.call(this);
        }
        return true;
      } else {
        this.invalidatePattern();
        if ((_ref1 = this._config.onFailure) != null) {
          _ref1.call(this);
        }
        return false;
      }
    };

    LockScreen.prototype.validatePattern = function() {
      return this;
    };

    LockScreen.prototype.invalidatePattern = function() {
      var dot, dots, line, _i, _len;
      dots = this._dotsOuterLayer.getChildren();
      line = this._lineLayer.getChildren();
      if (line[0] != null) {
        line[0].setFill("rgba(255,0,0,0.5)");
      }
      for (_i = 0, _len = dots.length; _i < _len; _i++) {
        dot = dots[_i];
        dot.setStroke("rgba(255,0,0,0.8)");
      }
      this._dotsOuterLayer.draw();
      this._lineLayer.draw();
      this._pattern.setToBeClearedOnNextUse(true);
      return this;
    };

    LockScreen.prototype.startRecordPattern = function() {
      this.clear();
      this._pattern.clearSavedPattern();
      this._pattern.setRecording(true);
      this._pattern.setToBeClearedOnNextUse(false);
      return this;
    };

    LockScreen.prototype.stopRecordPattern = function() {
      this.clear();
      this._pattern.setRecording(false);
      this._pattern.buildHint();
      return this;
    };

    LockScreen.prototype.showHint = function(canShow) {
      if (canShow) {
        this._pattern.showHint();
      } else {
        this._pattern.hideHint();
      }
      return this;
    };

    return LockScreen;

  })();

  Pattern = (function() {

    function Pattern(o) {
      var mousePos, stage;
      this._userDots = [];
      this._savedPattern = [];
      stage = o.patternLayer.getStage();
      mousePos = stage.getMousePosition() || {
        x: stage.getWidth() / 2,
        y: stage.getHeight() / 2
      };
      this._x0 = mousePos.x;
      this._y0 = mousePos.y;
      this._x = this._x0;
      this._y = this._y0;
      this._patternLayer = o.patternLayer;
      this._lineLayer = o.lineLayer;
      this._hintLayer = o.hintLayer;
      this._isRecording = false;
      this._toBeClearedOnNextUse = false;
    }

    Pattern.prototype.setRecording = function(state) {
      this._isRecording = state;
      return true;
    };

    Pattern.prototype.setToBeClearedOnNextUse = function(state) {
      this._toBeClearedOnNextUse = state;
      return true;
    };

    Pattern.prototype.buildHint = function() {
      var line;
      this._hintLayer.removeChildren();
      line = this._newLine(this._savedPattern);
      this._hintLayer.add(line);
      return true;
    };

    Pattern.prototype.showHint = function() {
      this._hintLayer.show();
      this._hintLayer.draw();
      return true;
    };

    Pattern.prototype.hideHint = function() {
      this._hintLayer.hide();
      this._hintLayer.draw();
      return true;
    };

    Pattern.prototype.addDot = function(dot, config) {
      var shouldDrawDot;
      if (this._toBeClearedOnNextUse) {
        this.clear();
        this._toBeClearedOnNextUse = false;
      }
      shouldDrawDot = this.shouldDrawDot(dot);
      if (shouldDrawDot) {
        if (this._isRecording) {
          this.savePatternDot(dot);
        } else if (shouldDrawDot) {
          this.addUserDot(dot);
        }
        this._patternLayer.add(dot);
        this.setTransition(dot, config);
        this._patternLayer.draw();
      }
      return true;
    };

    Pattern.prototype.shouldDrawDot = function(dot) {
      var d, dots, _i, _len;
      dots = this._isRecording ? this._savedPattern : this._userDots;
      for (_i = 0, _len = dots.length; _i < _len; _i++) {
        d = dots[_i];
        if (dot.getX() === d.getX() && dot.getY() === d.getY()) {
          return false;
        }
      }
      return true;
    };

    Pattern.prototype.setTransition = function(dot, config) {
      var _this = this;
      (function() {
        return dot.transitionTo({
          radius: config.radius,
          duration: 0.1,
          callback: _this.drawLine.bind(_this)
        });
      })();
      return true;
    };

    Pattern.prototype.addUserDot = function(dot) {
      this._userDots.push(dot);
      return true;
    };

    Pattern.prototype.drawLine = function() {
      var dots, line;
      dots = this._isRecording ? this._savedPattern : this._userDots;
      if (dots.length >= 2) {
        line = this._newLine(dots);
        this._lineLayer.removeChildren();
        this._lineLayer.add(line);
        this._lineLayer.draw();
      }
      return true;
    };

    Pattern.prototype._newLine = function(dots) {
      return new Kinetic.Shape({
        drawFunc: function() {
          var ctx, dot, dot1, i, _i, _ref;
          dot1 = dots[0];
          ctx = this.getContext();
          ctx.beginPath();
          ctx.moveTo(dot1.getX(), dot1.getY());
          for (i = _i = 1, _ref = dots.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            dot = dots[i];
            ctx.lineTo(dot.getX(), dot.getY());
          }
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.strokeStyle = "rgba(255,255,255,0.5)";
          ctx.lineWidth = 5;
          ctx.stroke();
          ctx.closePath();
          return true;
        },
        stroke: "rgba(255,255,255,0.5)",
        strokeWidth: 5
      });
    };

    Pattern.prototype.isValid = function() {
      var i, savedPattern, _i, _len, _ref;
      if (this._savedPattern.length !== this._userDots.length) {
        return false;
      }
      _ref = this._savedPattern;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        savedPattern = _ref[i];
        if (savedPattern.getX() !== this._userDots[i].getX() || savedPattern.getY() !== this._userDots[i].getY()) {
          return false;
        }
      }
      return true;
    };

    Pattern.prototype.clear = function() {
      this._clearUserDots();
      this._clearLayers();
      return this;
    };

    Pattern.prototype._clearUserDots = function() {
      return this._userDots = [];
    };

    Pattern.prototype._clearLayers = function() {
      var dot, dots, i, l, _fn, _i, _len,
        _this = this;
      dots = this._patternLayer.getChildren();
      l = dots.length;
      _fn = function() {
        return dot.transitionTo({
          radius: 0,
          duration: 0.1,
          callback: function() {
            if (l - 1 === i) {
              _this._patternLayer.clear();
              _this._patternLayer.removeChildren();
              _this._patternLayer.draw();
              return true;
            }
            return false;
          }
        });
      };
      for (i = _i = 0, _len = dots.length; _i < _len; i = ++_i) {
        dot = dots[i];
        _fn();
      }
      this._lineLayer.clear();
      this._lineLayer.removeChildren();
      this._lineLayer.draw();
      return true;
    };

    Pattern.prototype.savePatternDot = function(dot) {
      this._savedPattern.push({
        x: dot.getX(),
        y: dot.getY(),
        getX: function() {
          return this.x;
        },
        getY: function() {
          return this.y;
        }
      });
      return true;
    };

    Pattern.prototype.clearSavedPattern = function() {
      this._savedPattern = [];
      this._hintLayer.removeChildren();
      this._hintLayer.clear();
      this._hintLayer.draw();
      return true;
    };

    return Pattern;

  })();

}).call(this);
